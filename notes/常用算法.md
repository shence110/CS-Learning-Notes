# 算法

<!-- GFM-TOC -->
* [一、排序](#一排序)
    * [选择排序](#选择排序)
	* [插入排序](#插入排序)
    * [冒泡排序](#冒泡排序)
    


# 排序
计算排序算法的时间复杂度O时，主要考虑元素的**比较次数**和**交换次数**，
<br/>
比较可以通过 "<" 判断，交换则通过自己封装的swap()函数进行判断，这样比较容易观察和统计。

代码实现：
<br/>
```java
public class Sort {
    private void swap(int[] a, int i, int j) {
        a[i] ^= a[j];
        a[j] ^= a[i]; //j^i^j = i
        a[i] ^= a[j]; //i^j^i = j
    }
    ... sorting functions ...
}
```


## 选择排序
选择排序的精髓在于“选择”，每次选择数组待排元素中的最小元素，并于数组前端的元素交换。

排序过程：
<br/>
第1趟：遍历整个数组，选出最小值与数组第0位置元素交换，则第0位置排序完成；
<br/>
第2趟：遍历剩下1至n-1位置的元素，选出最小值与数组第1位置元素交换，则第0,1位置排序完成；
<br/>
......
<br/>
第n-1趟：最后比较n-1至n-2位置的元素，选出最小值与第n-1位置元素交换，则数组排序完成；

代码实现：
<br/>
```java
//选择排序
public void selectSort(int[] nums) {
    int N = nums.length;
    for (int i = 0; i < N - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < N; j++)
            if (nums[j] < nums[minIndex])
                minIndex = j;
        swap(nums, i, minIndex);
        System.out.println(Arrays.toString(nums));
    }
}
```

时间复杂度：
- 整个排序**最好**需要 **n<sup>2</sup>/2次比较** 和 **n次交换** ，时间复杂度为 **O(n<sup>2</sup>)**；
- 整个排序**平均**需要 **n<sup>2</sup>/2次比较** 和 **n次交换** ，时间复杂度为 **O(n<sup>2</sup>)**；
- 整个排序**最坏**需要 **n<sup>2</sup>/2次比较** 和 **n次交换** ，时间复杂度为 **O(n<sup>2</sup>)**。

特点：
- 无论输入数组是否有序，比较和交换次数都不变。
- 交换过程中，值相同的元素的先后位置可能改变，因此**不稳定**。
- 排序过程中需要辅助变量，空间复杂度为 **O(1)**。


## 插入排序
每一趟都取待排序元素中的第一个，插入已经排序的元素中，使得已经排序的元素依然有序。

排序过程：
<br/>
第1趟：取出1位置的元素，与0位置的元素比较，顺序错误则交换，则0,1位置元素有序；
<br/>
第2趟：取出2位置的元素，依次与1,0位置的元素比较，顺序错误则交换，直到顺序正确，则0~2位置元素有序；
<br/>
......
<br/>
第n-1趟：取出n-1位置的元素，依次与n-2到0位置的元素比较顺序错误则交换，直到顺序正确，则数组排序完成；

代码实现：
<br/>
```java
//插入排序
public void insertionSort(int[] nums) {
    int N = nums.length;
    for (int i = 1; i < N; i++) {
        for (int j = i; j > 0 && nums[j-1] > nums[j]; j--)
            swap(nums, j, j - 1);
        System.out.println(Arrays.toString(nums));
    }
}
```

时间复杂度：
- 整个排序**最好**需要 **n-1次比较** 和 **0次交换** ，时间复杂度为 **O(n)**，此时数组有序；
- 整个排序**平均**需要 **n<sup>2</sup>/4次比较** 和 **n<sup>2</sup>/4次交换** ，时间复杂度为 **O(n<sup>2</sup>)**；
- 整个排序**最坏**需要 **n<sup>2</sup>/2次比较** 和 **n<sup>2</sup>/2次交换** ，时间复杂度为 **O(n<sup>2</sup>)**，此时数组为倒序。

特点：
- 如果某次比较发现元素插入位置已经正确，则结束后续比较工作。
- 取值和插入过程中，值相同的元素的先后位置不变，因此**稳定**。
- 排序过程中需要辅助变量，空间复杂度为 **O(1)**。


## 冒泡排序
冒泡排序每次从左到右比较数组中相邻的元素，如果相邻元素的顺序错误，则交换相邻元素，
<br/>
每趟过后都会使得最大的元素被交换到剩余元素的末位上。

排序过程：
<br/>
第1趟：遍历整个数组，每次判断相邻元素，顺序错误则交换，则第n-1位置排序完成；
<br/>
第2趟：遍历剩下0~n-2数组，每次判断相邻元素，顺序错误则交换，则第n-2,n-1位置排序完成；
<br/>
......
<br/>
第n-1趟：遍历剩下0,1位置的元素，顺序错误则交换，则数组排序完成；

代码实现：
<br/>
```java
//冒泡排序
public void bubbleSort(int[] nums) {
    int N = nums.length;
    boolean sorted = false;
    for (int i = N - 1; i > 0 && !sorted; i--) {
        sorted = true;
        for (int j = 0; j < i; j++)
            if (nums[j] > nums[j + 1]) {
                swap(nums, j, j + 1);
                sorted = false;
            }
        System.out.println(Arrays.toString(nums));
    }
}
```

时间复杂度：
- 整个排序**最好**需要 **n-1次比较** 和 **0次交换** ，时间复杂度为 **O(n)**，此时数组有序；
- 整个排序**平均**需要 **n<sup>2</sup>/4次比较** 和 **n<sup>2</sup>/4次交换** ，时间复杂度为 **O(n<sup>2</sup>)**；
- 整个排序**最坏**需要 **n<sup>2</sup>/2次比较** 和 **n<sup>2</sup>/2次交换** ，时间复杂度为 **O(n<sup>2</sup>)**，此时数组为倒序。

特点：
- 如果某一趟发现数组已经排序完成，则会及时退出避免无效操作。
- 交换过程中，值相同的元素的不会进行交换，因此**稳定**。
- 排序过程中需要辅助变量，空间复杂度为 **O(1)**。





